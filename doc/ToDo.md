# üõ†Ô∏è Engine To-Do List

### ‚úÖ **Project Infrastructure**

- [x] Create a build system
  
  - [x] Consider Conan for dependency management
  
  - [x] Support Multiple Builds
    
    - [x] Windows (Debug/Release)
    
    - [x] Emscripten (Debug/Release)

- [ ] Restructure build system to use `.bat` (Windows) and `.sh` (Linux/macOS) wrapper scripts for **interchangeable IDE** support
  
  - [x] VSCode tasks should only reference these wrapper files, not direct commands
  - [x] Decide which scripting format makes most sense:
    - `.bat` / `.ps1` for Windows
    - `.sh` for Linux/macOS
    - Python for portability?
  - [ ] Build for Linux and macOS

- [x] Define a `external/` directory for external libs (GLM, stb, etc.)

- [x] Setup Example Project for Windows

- [x] Setup Example Project for Emscripten

---

### üß± **Core Engine Structure**

- [ ] Define `Engine` entry point (init, run, shutdown)
- [ ] Add `Application` wrapper with main loop and `onFrame`, `onResize`, etc. callbacks
- [x] Implement time management (deltaTime, totalTime)
- [x] Implement logging system
	- [x] Implement logger (using spdlog)
	- [ ] Automatic logger building in Core structures (via ResourceManager)
- [ ] Replace returns from optional to variant or custom result to have better error handling

---

### üé® **Rendering**

- [x] Set up WebGPU context and swapchain
- [x] Basic renderer pipeline (color + depth)
- [x] Abstract `Shader` class with safe uniforms API
  - [x] Load WGSL shaders from file
  - [ ] Allow user to change shader values safely via C++ API (via bind groups and uniforms)
  - [ ] **Slang Support!!!**
- [ ] Consider Shader Reflection by using a library once it exists or writing a parser so the renderpipline can be autogenerated
- [ ] Implement `Material` abstraction
  - [ ] Supports multiple shader types (basic, PBR, etc.)
  - [x] Expose common properties (base color, roughness, metallic, etc.)
- [x] Implement `Mesh` abstraction
  - [ ] VBO/IBO support
- [x] Basic lighting (Directional, Point, Spot, Ambient)
- [ ] Support shadows (depth map)
- [ ] Add support for transparency
- [ ] Add post-processing stage (bloom, tone mapping)

---

### üßç‚Äç‚ôÇÔ∏è **Scene & Entity Management**

- [ ] Entity-Component-System (or pseudo-ECS) design
- [ ] Scene graph with transforms
	- [ ] Node-based hierarchy with parent/child relationships
	- [x] Transform component with position, rotation, scale
	- [x] Specialized node types (UpdateNode, RenderNode, CameraNode)
	- [x] Scene management with update/lateUpdate/render lifecycle
- [ ] SceneManager
  - [ ] Load/Save scenes from `.scene` file
  - [ ] Register and resolve asset references (by name or ID)
  - [ ] Optional: pack scene + all assets into one bundle
- [x] AssetManager
  - [x] Handle textures, materials, meshes, shaders
  - [x] Reference-counted or shared pointers (via Handle<T> system)

---

### üì¶ **Assets & File Formats**

- [x] OBJ loader for static mesh support
- [x] Support PNG/JPEG textures (via stb_image)
- [ ] Add glTF loader (implemented via tinygltf)
- [x] Default material/shader templates
- [x] Create file watcher for hot-reload (shader hot-reload implemented)

---

### üß™ **Tooling & Debugging**

- [x] Simple in-app UI for dev tools (e.g., ImGui)
- [x] Frame statistics overlay (FPS, memory, draw calls)
- [x] Resource reloading (shader hot-reload with F5)
- [x] Add debug view modes (debug axes for lights)
- [ ] Add more debug view modes (normals, depth, wireframe)

---

### üß∞ **Utilities**

- [x] Math library integration (GLM)
- [x] UUID generator for assets/entities (via Identifiable<T> system with uint64_t IDs)
- [ ] Serialization system 

---

### üîÆ Future

- [ ] Physics Engine Integration (start planning structure)
  - [ ] Collision system (AABB, spheres, mesh colliders)
  - [ ] Rigidbody support
  - [ ] Physics material system
- [ ] Animation system
- [ ] Editor GUI (level editor, asset browser)

---

## üî¨ Future Research Topics

*Interesting topics that are out of scope for this project but could be valuable for future research or theses:*

### **Rendering Optimization**
- **Light Culling & Clustering**: Implement tiled/clustered lighting for handling large numbers of dynamic lights efficiently
- **GPU-Driven Rendering**: Move draw call generation to GPU using compute shaders and indirect rendering
- **Virtual Texturing**: Implement sparse virtual textures for massive texture datasets
- **Visibility Culling**: Occlusion culling, frustum culling optimization, potentially using compute shaders

### **Advanced Rendering Techniques**
- **Ray Tracing Integration**: Hybrid rasterization/ray tracing pipeline using WebGPU compute
- **Global Illumination**: Real-time GI using techniques like DDGI, RTXGI, or voxel-based approaches
- **Atmospheric Scattering**: Physically-based sky and atmosphere rendering
- **Volumetric Effects**: Volumetric fog, clouds, and lighting

### **Engine Architecture**
- **Job System**: Multi-threaded task scheduler for parallel CPU work
- **Asset Streaming**: Async loading and LOD streaming for large open worlds

### **Shader Development**
- **Shader Graph System**: Visual shader editor like Unity Shader Graph or Unreal Material Editor
- **Shader Variants & Permutations**: Uber-shader system with feature toggles
- **Cross-API Shader Compiler**: Unified shader source targeting WebGPU, Vulkan, D3D12

### **Platform & Performance**
- **Mobile WebGPU**: Optimize for mobile browsers and investigate performance characteristics
- **WASM SIMD**: Leverage WebAssembly SIMD for CPU-side calculations
- **Profiling Tools**: Custom GPU/CPU profiler integration with visualization
- **Memory Management**: Custom allocators, memory pooling strategies

### **AI & Procedural**
- **Neural Texture Compression**: ML-based texture compression research
- **Procedural Generation**: Runtime procedural mesh/texture generation on GPU
- **AI-Assisted Tools**: ML-based asset optimization, LOD generation, or texture upscaling


